/*
 * This Scala source file was generated by the Gradle 'init' task.
 */
package taller

import common._
import org.scalameter._
import taller.RiegoOptimo

object App {

  // Método principal del programa
  def main(args: Array[String]): Unit = {
    println(greeting())
    println("\n....... Iniciando benchmarking de Riego Optimo .......")
    benchmarkingCostos()
    //benchmarkingProgramaciones()
    //benchmarkingOptimo()

  }

  def greeting(): String = "Hello, world!"

  //------------------ VERSION NUMERO 1 DE BENCHMARKING ------------------

  // Benchmarking para los costos de riego y movilidad
  def benchmarkingCostos(): Unit = {
    val riego = new RiegoOptimo() // Instancia de la clase RiegoOptimo
    println("\n------------- Benchmarking: Costos de Riego y Movilidad ----------------")
    val tamanos = List(10,3,4,5) // Tamaños de las fincas a evaluar
    // Iteramos sobre los tamaños de las fincas
    for (tamano <- tamanos) {
      val finca = riego.fincaAlAzar(tamano)
      val distancia = riego.distanciaAlAzar(tamano)
      val programacion = riego.generarProgramacionesRiego(finca).head // Tomamos una programación
      
      println(f"\n------ Tamaño finca: $tamano ------")
      riego.compararCostos(riego.costoRiegoFinca, riego.costoRiegoFincaPar, "Secuencial", "Paralelo")(finca, programacion)
      riego.compararCostosMovilidad(riego.costoMovilidad, riego.costoMovilidadPar, "Secuencial", "Paralelo")(finca, programacion, distancia)
      
    }
  }

  // Benchmarking para la generación de programaciones de riego
  def benchmarkingProgramaciones(): Unit = {
    val riego = new RiegoOptimo()
    println("\n------------- Benchmarking: Generación de Programaciones de Riego ----------------")
    val tamanos = List(5, 6, 7) // Tamaños más pequeños debido al crecimiento factorial

    for (tamano <- tamanos) {
      val finca = riego.fincaAlAzar(tamano)
      println(f"\n------ Tamaño finca: $tamano ------")
      riego.compararGeneracion(riego.generarProgramacionesRiego, riego.generarProgramacionesRiegoPar, "Secuencial", "Paralelo")(finca)
    }
  }

  // Benchmarking para la programación de riego óptima
  def benchmarkingOptimo(): Unit = {
    val riego = new RiegoOptimo()
    println("\n------------- Benchmarking: Programación de Riego Óptima ----------------")
    val tamanos = List(5, 6, 7) // Tamaños factibles para evaluación

    for (tamano <- tamanos) {
      val finca = riego.fincaAlAzar(tamano)
      val distancia = riego.distanciaAlAzar(tamano)
      println(f"\n------ Tamaño finca: $tamano ------")
      riego.compararOptimo(riego.ProgramacionRiegoOptimo, riego.ProgramacionRiegoOptimoPar, "Secuencial", "Paralelo")(finca, distancia)
    }
  }



}
